<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>git_2</title>
<style>
/* 초기화 */
*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

li{
  list-style-type: none;
}

/* 보여줄 구간의 높이와 넓이 설정 */
#slideShow{
  width: 850px;
  height: 600px;
  position: relative;
  margin: 50px auto;
  overflow: hidden;
  /*리스트 형식으로 이미지를 일렬로 
  정렬할 것이기 때문에, 500px 밖으로 튀어 나간 이미지들은
  hidden으로 숨겨줘야됨*/
}


.slides{
  position: absolute;
  left: 0;
  top: 0;
  width: 10000px; /* 슬라이드할 사진과 마진 총 넓이 */
  transition: left 0.5s ease-out; 
  /*ease-out: 처음에는 느렸다가 점점 빨라짐*/
}

/* 첫 번째 슬라이드 가운데에 정렬하기위해
첫번째 슬라이드만 margin-left조정 */
.slides li:first-child{
  margin-left: 100px;
}

/* 슬라이드들 옆으로 정렬 */
.slides li:not(:last-child){
  float: left;
  margin-right: 100px;
}

.slides li{
  float: left;
}

.controller span{
  position:absolute;
  background-color: transparent;
  color: black;
  text-align: center;
  border-radius: 50%;
  padding: 10px 20px;
  top: 50%;
  font-size: 1.3em;
  cursor: pointer;
}

/* 이전, 다음 화살표에 마우스 커서가 올라가 있을때 */
.controller span:hover{
  background-color: rgba(128, 128, 128, 0.11);
}

.prev{
  left: 10px;
}

/* 이전 화살표에 마우스 커서가 올라가 있을때 
이전 화살표가 살짝 왼쪽으로 이동하는 효과*/
.prev:hover{
  transform: translateX(-10px);
}

.next{
  right: 10px;
}

/* 다음 화살표에 마우스 커서가 올라가 있을때 
이전 화살표가 살짝 오른쪽으로 이동하는 효과*/
.next:hover{
  transform: translateX(10px);
}
</style>
</head>
<body>
    <div id="slideShow">
        <ul class="slides">
          <li><img src="source/git2_src/스크린샷 1.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 2.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 3.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 4.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 5.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 6.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 7.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 8.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 9.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 10.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 11.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 12.png" alt=""></li>
          <li><img src="source/git2_src/스크린샷 13.png" alt=""></li>

        </ul>  
        <p class="controller">
          
          <!-- &lang: 왼쪽 방향 화살표
          &rang: 오른쪽 방향 화살표 -->
          <span class="prev">&lang;</span>  
          <span class="next">&rang;</span>
        </p>
      </div>
      <script src="source/git2_src/JS/slideShow.js"></script>
      
</body>
</html>

    <!--
    <div class="slider">
        <h1>git & GitHub</h1>
        <h4>Branch 사용</h4><br>
    </div>

    <div class="slider">
        <h2 id ="border3">브랜치(Branch)</h2>
        <h3>○ Branch를 사용하는 이유</h3>
        <ul>
            <li>Master는 stable버전을 관리하므로 먼저 branch에서 새로운 기능을 테스트한 후 master와 병합</li>
            <li>버그 수정, 기능 추가 등, 다수의 개발자가 협업할 때 동일한 소스코드를 기반으로 서로 다른 작업을 가능하게 한다.</li>
            <li>코드 개선을 위해 주석 처리하고 새로운 코드를 추가하는 대신 branch 사용을 권장</li>
            <li>reset 명령으로 취소하기 어려운 경우, 임시 branch를 만들어 Merge와 Rebase테스트에 사용</li>
            <li>특정 commit으로 되돌아 가고 싶을 때</li>
        </ul><br>
    </div>
    <div class="slider">
        <h3>○ 브랜치는 하나의 작업단위별로 만드는 것이 좋다.(하나의 브랜치에서 여러 작업을 지양)</h3>
        <img src="source/git2_src/스크린샷 2023-11-26 182540.png" width="600" height="300" alt="Image 1">
        <h3>○ 워크 플로우</h3>
        <ul>
            <li>저장소를 생성하면 자동으로 만들어지는 master(혹은 main)branch에서 각자의 전용 branch를 생성(checkout)</li>
            <li>오류나 버그를 수정하는 branch의 경우 hotfix 또는 bugfix와 같은 이름을 주로 사용</li>
            <li>하나의 작업 단위별로 branch 생성(여러 작업을 하나의 branch에서 수행하는 것은 피해야 함)</li>
            <li>Branch로 특정 작업을 수행하고 그 결과를 병합</li>
        </ul><br>
    </div>

    <div class="slider">
        <h2 id ="border3">브랜치(Branch)생성과 관리</h2>
        <h3>○ Branch 표기</h3>
        <table>
            <tr>
                <td>
                    <ul>
                        <li>최신 commit에서 부모 commit으로 화살표를 그린다.</li><br>
                        <li>Commit을 실행하면 commit객체가 생성</li><br>
                        <li>Branch는 커밋 객체 하나를 가리키지만 논리적으로 commit과 조상을 하나로 묶은 것&nbsp;&nbsp;</li>
                    </ul>

                </td>
                <td>
                    <img src="source/git2_src/스크린샷 2023-11-26 200238.png" width="200" height="300">
                </td>
            </tr>
        </table>
    </div>

    <div class="slider">
        <h2 id ="border3">브랜치(Branch) 실습</h2>
        <h3>○ Branch 생성</h3>
        <ul>
            <li>로컬 저장소를 위한 폴더를 만들고 원격 저장소 받아오기(클론: clone)<br>&nbsp;
                $ mkdir branch_prac<br>&nbsp;
                $ cd branch_prac<br>&nbsp;
                $ git clone https://github.com/id/저장소 이름.git<br>&nbsp;
                $ ls -al<br>&nbsp;
                $ git log
            </li><br>
            <li>다음 명령으로 issue1 브랜치를 생성한다.<br>&nbsp;
                $ git branch issue1<br>&nbsp;
                # 생성된 branch 확인<br>&nbsp;
                $ git branch
            </li>
        </ul>
    </div>

    <div class="slider">
        <h3>○ Branch 전환</h3>
        <ul>
            <li>checkout (branch_name) 명령으로 해당 브랜치로 이동한다.<br>&nbsp;
                ºcheckout 명령은 branch 안에 있는 마지막 커밋 내용을 작업 트리에 옮겨 놓는다.<br>&nbsp;
                $ git checkout -b (branch name) 명령은 branch 생성과 이동을 동시에 수행한다.<br>&nbsp;
                $ git checkout issue1</li><br>
            <li>
                Branch에서 새 파일을 만들고 commit 수행<br>&nbsp;
                $ echo "This file is first br1 Text" >> br1.txt<br>&nbsp;
                $ git add br1.txt<br>&nbsp;
                $ git commit -m "first branch commit"
            </li>
        </ul><br>
    </div>
    
    <div class="slider"> 
        <h3>○ Branch merge (병합)</h3>
        <ul>
            <li>
                merge 명령으로 branch를 master에 병합한다.<br>&nbsp;
                # 먼저 master branch로 이동<br>&nbsp;
                $ git checkout master<br>&nbsp;
                
                #병합 전에 branch에서 작업한 파일이 있는지 확인하고, branch를 master에 병합<br>&nbsp;
                $ git merge issue1<br>&nbsp;

                # 실행 결과는 'ls -al'이나 'git log' 명령으로 확인
            </li>
        </ul><br>
    </div>
    
    <div class="slider"> 
        <h3>○ Branch 삭제</h3>
        <ul>
            <li>
                Branch를 master에 병합하고 나면 더 이상 branch가 필요 없기 때문에 이를 삭제한다.<br>&nbsp;
                # branch 삭제는 이름으로 삭제<br>&nbsp;
                $ git branch -d issue1<br>&nbsp;
                $ git branch <br>&nbsp;
            </li>
            <li>
                issue2 에서 br1.txt 파일에 새로운 내용을 추가한 후에 commit한다.<br>&nbsp;
                $ echo " contents were added by branch issue2" >> br1.txt<br>&nbsp;
                $ git add br1.txt<br>&nbsp;
                $ git commit -m " second branch commit"
            </li>
        </ul><br>
        </div>
        
        <div class="slider"> 
        <h3>○ 동시 작업</h3>
        <ul>
            <li>
                Issue3로 전환해서 br1.txt파일에 내용을 추가한 다음 커밋한다.<br>&nbsp;
                ＊ 현재 br1.파일에는 issue2에서 변경한 내용을 볼 수 없다.<br>&nbsp;
                $ git checkout issue3<br>&nbsp;
                $ echo "Contents were added by branch issue3" >> br1.txt<br>&nbsp;
                $ git add br1.txt<br>&nbsp;
                $ git commit -m "third branch commit"
            </li>
        </ul><br>
    </div>

    <div class="slider"> 
    <h3>○ 충돌(conflict) 발생과 해결</h3>
        <ul>
            <li>
                issue3에서 변경한 부분과 issue2에서 변경한 부분을 모두 master branch에 병합한다.
            </li><br>
            <li>
                master branch로 전환한 다음 issue2 branch를 병합<br>&nbsp;
                $ git checkout<br>&nbsp;
                $ git merge issue2 # fast-forward 병합 실행
            </li><br>
            <li>
                conflict 해결 - 충돌이 발생한 부분을 하나하나 확인해서 수정해야 한다.<br>&nbsp;
                º 다음과 같이 파일을 변경한다.<br>&nbsp;
                This file is first br1.txt<br>&nbsp;
                Contents were added by branch issue2<br>&nbsp;
                Contents were added by branch issue3<br>&nbsp;
            </li><br>
            <li>
                파일을 수정했으면 다시 commit한다.<br>&nbsp;
                $ git add br1.txt<br>&nbsp;
                $ git -m "third branch commit"
            </li>
        </ul><br>
    </div>
    
    <div class="slider"> 
    <h3>○ Rebase로 병합하기 - Rebase를 먼저 실행한 후에 병합</h3>
        <ul>
            <li>
                마지막 명령 실행 취소<br>&nbsp;
                $ git reset --hard HEAD~<br>&nbsp;
                <img src="source/git2_src/스크린샷 2023-11-26 182642.png" width="300">            
            </li><br>
            <li>
                issue3 branch로 checkout 후에 master branch에 대해 Rebase 실행<br>&nbsp;
                $ git checkout issue3<br>&nbsp;
                $ git rebase master 
            </li><br>
            <li>br1.txt 파일에는 merge때와 마찬가지로 충돌이 발생한 내용이 있기 때문에 이를 적절히 수정한다.</li><br>
            <li>
                rebase 명령 재실행<br>&nbsp;
                $ git add br1.txt<br>&nbsp;
                $ rebase 후에 충돌을 수정한 후에는 commit이 아닌 --continue 옵션을 사용한다.<br>&nbsp;
                $ git rebase --continue<br>&nbsp;
                º rebase 명령 자체를 취소하려면 --abort 옵션을 사용<br>&nbsp;
                <img src="source/git2_src/스크린샷 2023-11-26 182647.png" width="400">
            </li><br>
            <li>
                master branch에서 변경사항 병합<br>&nbsp;
                º 현재 issue3 branch의 위치가 앞쪽으로 옮겨졌을 뿐 master branch는 아직 issue3의 변경 내용을 병합하지 못한 상태이다.<br>&nbsp;
                º 이제 master branch로 전환한 다음 issue3 branch의 변경 사항을 모두 병합한다.<br>&nbsp;
                $ git checkout master<br>&nbsp;
                $ git merge issue3<br>&nbsp;
            </li>
        </ul><br>
    </div>
    
    <div class="slider"> 
        <h2 id ="border3">브랜치(Branch)생성과 관리</h2>
        <h3>○ 브랜치 생성</h3>
        <ul>
            <li>
                git branch(-v)<br>&nbsp;
                º 로컬 브랜치 목록 표시, -v 옵션은 마지막 커밋도 함께 표시<br>&nbsp;
            </li><br>
            <li>
                git branch(-f) (브랜치 이름) (커밋 체크섬)<br>&nbsp;
                º 새로운 브랜치 생성, 체크섬 값이 없으면 HEAD로부터 생성<br>&nbsp;
                º -f옵션은 브랜치를 다른 커밋으로 옮기고 싶을 때 사용
            </li><br>
            <li>
                git branch -r[v]<br>&nbsp;
                º 원격 저장의 브랜치 표시, -v 옵션을 추가하면 커밋 요약 정보 제공
            </li><br>
            <li>
                git checkout [브랜치 이름]<br>&nbsp;
                º 특정 브랜치로 체크아웃, 브랜치 이름 대신 체크섬을 사용할 수 있지만 브랜치 이름을 사용할 것을 강력 추천
            </li><br>
            <li>
                git checkout -b[브랜치 이름][커밋 체크섬]<br>&nbsp;
                º 특정 커밋에서 브랜치를 생성하고 체크아웃 수행, 두 명령을 합친 것으로 간결해서 자주 사용
            </li><br>
        </ul>
    </div>
    
    <div class="slider"> 
        <h3>○ 브랜치 생성</h3>
        <ul>
            <li>
                git merge<br>&nbsp;
                º 현재 브랜치와 대상 브랜치를 병합. 병합 커밋이 새로 생기는 경우가 많다.<br>&nbsp;
            </li><br>
            <li>
                git rebase (대상 브랜치)<br>&nbsp;
                º 내 브랜치의 커밋들을 대상 브랜치 다음으로 재배치. 히스토리가 깔끔해서 자주 사용하지만 조심해야한다.
            </li><br>
            <li>
                git branch -d<br>&nbsp;
                º 특정 브랜치 삭제. HEAD 브랜치나 병합되지 않은 브랜치는 삭제할 수 없다.
            </li><br>
            <li>
                git branch -D [브랜치 이름]<br>&nbsp;
                º 브랜치를 강제로 삭제. -d로 지울 수 없는 브랜치 삭제에 사용할 수 있지만 조심해야 한다.
            </li><br>
        </ul>
    </div>
        
    <div class="slider">
        <h3>○ HEAD</h3>
        <ul>
            <li>
                현재 작업 중인 브랜치를 가리킴<br>
            </li><br>
            <li>
                브랜치는 최신 커밋을 가리키므로, 결과적으로 HEAD는 현재 작업 중인 브랜치의 최신 커밋을 가리킨다.
            </li>
        </ul>
    </div>
    
    <div class="slider"> 
        <h3>○ Revert</h3>
        <ul>
            <li>
                커밋을 되돌리고 싶을 때:<br>&nbsp;
                새로운 브랜치를 만들고, 변경 사항을 직접 수정해서 [master]브랜치에 pull request를 통해 병합<br>&nbsp;
                Rebase -I 등을 통해 필요한 커밋만 남기고 [master]브랜치에 강제 푸시(push--force)
            </li><br>
            <li>
                취소하고 싶은 F1과 F2커밋이 있고, 그 사이에 C2와 C3 커밋이 있는 경우, git revert명령으로 쉽게 해결 가능하다.<br>&nbsp;
                $git revert F2<br>&nbsp;
                $git revert F1
            </li><br>
            <li>
                취소하는 커밋(RF2, RF2)을 만들어 내고, 이전 히스토리를 변경하지 않으면서 히스토리 중간의 여러 커밋 내용을<br>
                상태로 되돌릴 수 있다.
            </li>
        </ul>
    </div>

    <div class="slider"> 
        <h3>○ reset으로 브랜치 되돌리기</h3>
        <ul>
            <li>다음 명령은 브랜치를 지정한 커밋으로 옮기고 작업 폴더의 내용도 변경한다.<br>&nbsp;
            $git reset --hard (이동할 커밋 체크섬)
            </li>
        </ul>
        <h3>○ 병합 상황에서 rebase 하기</h3>
        <ul>
            <li>
                git rebase(대상 브랜치)<br>&nbsp;
                대상 브랜치에만 있는 새로운 커밋을 현재 브랜치 위로 재배치한다.
            </li>
        </ul>
    </div>

    <div class="slider"> 
        <h3>○ 배포 버전에 태그(Tag)붙이기</h3>
        <ul>
            <li>태그(tag)는 주석 있는 태그와 간단한 태그 두 종류가 있다. (일반적으로 주석 있는 태그 사용을 권장)</li>
            <li>태그는 차 후, 커밋을 식별할 수 있는 유용한 정보</li>
            <table>
                <tr>
                    <td>git tag -a -m(간단한 메세지)(태크 이름)<br>
                    (브랜치 또는 체크섬)</td>
                    <td>-a로 주석있는 태그를 생성한다.<br>
                        메세지와 태그 이름은 필수이며, 브랜치 이름을 생략하면<br>
                        HEAD에 태그를 생성한다.</td>
                </tr>
                <tr>
                    <td>git push (원격저장소 별명) (태그 이름)</td>
                    <td>원격 저장소에 태그를 업로드한다.</td>
                </tr>
            </table>
        </ul>
    </div>
-->